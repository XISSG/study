# 十六章
# API安全
## API安全概述
近几年移动互联网快速发展，再加上IoT设备不断普及，API在应用开发中扮演这越来越重要的角色。基本上所有的App与服务端的数据调用都是通过API进行的。在有关调查中发现，API流量已经占到了web流量的83%，而且这个数字还在不断增长。同时，攻击者也将目光转向快速增长的API，大量安全事件都是由API安全漏洞导致的。
在web应用安全中，很多数据安全事件都与API安全关系紧密，比如API的认证和授权机制存在缺陷，或者缺少API限速机制时，都有可能产生数据泄露事件。
在常规的web应用中，我们很容易看到服务端提供的各种URL，也有很多成熟的web漏洞扫描器可以用于自动化测试，而且开放在互联网上的网站需要经受大量扫描器和攻击者的探测，常规的安全漏洞通常很快就能暴露 出来。但是，API漏洞通常藏得更深，比如那些采用了HTTPS协议的App或IoT设备，对其抓包，分析网络流量会比较麻烦，所以针对API的安全测试相对少一些。这就导致很多API相关的安全问题很难暴露出来，当有耐心的攻击者深入分析API时，往往能够发现大量安全漏洞。
## 常见API架构
不管是移动App、IoT设备，还是后端的微服务架构，基于HTTP/HTTPS协议来实现的API调用都是最常见的方式。虽然它们都使用同样的应用层协议，但是却遵循不同的数据交互模式和规范。数据交互模式和规范成为API架构(或风格)
### SOAP
早期流行的是SOAP(Simple Object Access Protocol)通信协议，它是一种XML格式的数据封装协议，最初由微软发布。SOAP消息包含一个Envelope根元素，其中包含了可选的Header元素和必须的Body元素：
```
<?xml version="1.0"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2001/12/soap-envelope"
soap:encodingStyle="http://www.w3.org/2001/12/soap-encoding">
<soap:Header></soap:Header>
<soap:Body></soap:Body>
</soap:Envelope>
```
虽然SOAP成为简单对象访问协议，但是实际上在真正使用时，由于它支持XML封装消息，并且有很强的约束，会让消息显得非常复杂和冗长。而且，SOAP只支持通过HTTP POST方法发送消息。在web应用中使用JavaScript访问SOAP API和解析数据就很麻烦。
SOAP集成了WS-Security安全规范，可以使用令牌、签名和加密的方式来实现身份认证，安全传输消息。在Java应用中，可以使用WSS4J库来实现WS-Security安全规范。在高安全级别的企业应用中，SOAP的使用非常广泛。
### REST
另一种成为REST(Representational State Transfer)的API架构在2000年出现，符合REST风格的API也被称为RESTful API。REST和SOAP的设计理念有很大不同，它没有SOAP那样风格的约束，而是将客户端和服务端完全解耦，客户端通过URI来指定请求的资源，服务端使用非常简单的数据格式(通常是JSON)来表示返回的资源，而且主要使用HTTP原生的协议来实现相应的功能，例如GET、PUT和DELETE方法分别用于获取、上传和删除操作。
REST API本身不提供安全保护能力，所以身份认证、数据签名等操作必须由开发者通过其他方式来实现。常见的认证方式有使用Authorization头，或者一个自定义的Token参数来标识调用者的身份。最常见的签名做法是，对请求中的参数计算基于哈希的消息认证码(HMAC)，因为它要求实现协商一个共享密钥，所以在服务端的API调用中比较常见。
云厂商对外提供的公共API大多使用HMAC认证身份，它会向用户提供一个AccessKeyId和一个AccessKeySecret，前者用于标识调用者身份，后者用于计算HMAC签名，用户需要 安全地保管它们。
REST框架充分利用了HTTP协议自身的特性，API中的不同功能都基于HTTP方法(GET/POST/PUT/DELETE)和URI的组合来实现。例如，可分别通过如下请求来实现获取用户信息和删除用户信息的功能：
```
GET /user/1234
DELETE /user/1234
```
与SOAP相比，REST更简洁、灵活，并且有更强的语义表达，因此很快超越SOAP成为最流行的API框架。直到今天，互联网上的大部分API都是REST架构。
REST架构在HTTP协议的基础上并没有定义过多的规范，所以它本身的安全问题基本上等同常规的web安全问题，像更常见的SQL注入、CSRF漏洞、SSRF漏洞都有可能存在与REST API中，一般都可以采用常规的web安全方案去解决
REST API本身也有缺陷，最典型的缺陷就是API设计好以后其功能是固定的。比如，一个获取用户信息的API，即使客户端只需要只需要获取"姓名"这个字段，但是通常REST API会返回用户的全部信息，很多时候这样做不仅浪费宽带，而且存在过度获取信息的问题。另外，客户端不能在一个API请求中获取很多中不同的类型的数据，例如在一个博客系统中，如果客户端需要获取用户的身份信息及该用户发表的文章，就要调用两个不同的API来实现，通常不会在一个REST API中混杂不同的数据。
### GraphQL
REST API存在的这些问题，正是Facebook在2012年推出GraphQL API的主要驱动力。
GraphQL API被认为是API的未来，它和REST有点像，但又有独特的优势。其最大的特色是可以在一个API调用中精确获取想要的数据，有点像在SQL中的SELECT语句中指定想要查询的列。同时GraphQL还支持一次API调用获取多种不同类型的数据，因此如果web页面需要加载多种数据，使用GraphQL API会拥有更好的性能。
此外，GraphQL还是自省的(Introspection)，即可以通过调用GraphQL API来获取其格式的定义，包含所有的数据类型和字段。这相当于API自带文档，而且它是随着API的变更自动更新的。
GraphQL添加了功能更强大的新特性，但是同时这些特性也可能带来安全隐患。最直接的就是拒绝服务攻击(Dos)。GraphQL查询数据时较为灵活，利用这些特性可以使用很少的HTTP请求就让服务端执行大量操作，从而消耗服务端资源，使其无法提供正常服务。
例如，下面的查询语句让服务端查询99999999个对象：
```
query{
    autor(id:"abc"){
        posts(first: 99999999){
            titile
        }
    }
}
```
这种拒绝服务攻击的方式在REST API中也可能会存在，例如很多分页查询中的PageSize由客户端指定，用户提交一个超大的PageSize就可能导致拒绝服务。GraphQL支持高级的嵌套查询，更容易产生拒绝服务，比如可以查询一个专辑中的歌曲，再查询歌曲所属的专辑，然后不断嵌套下去，那么查询所消耗的资源将爆炸式增长，如：
```
query evil{                        #Depth:0
    album(id:42){                  #Depth:1
        songs{                     #Depth:2
            album{                 #Depth:3
                songs{             #Depth:4
                    ...重复1000次   #Depth:1000
                }
            }
        }
    }
}
```
另外，因为GraphQL较灵活，使用它进行批量查询，还能实现其他攻击效果。在一些使用了GraphQL的登录接口中，攻击者可以在一个请求中提交多个账号密码对，这样就可以在一个请求中探测多个账号密码对，从而提高暴力破解的效率。  如果应用在使用动态口令或短信验证码做多因素认证处理不当，则攻击者就可以在一次GraphQL请求中尝试多个验证码，就有更大的概率猜中验证码，从而绕过二次验证。
GrapQL的自省特性虽然给开发者带来了方便，但是它显示了所有数据类型和字段信息，相当于向攻击者暴露所有API(可以使用自动化工具graphdoc生成文档)。例如，在正常业务中查询的是用户信息的id和name字段，但是GraphQL自省特性暴露了User对象中还存在password字段，修改查询你参数就能获取password字段的内容。
攻击者通过遍历很快就可以找到存在问题的对象，比如存储用户身份信息、密码及密钥的对象，从而产生数据泄露。
由于GraphQL也是一门查询语言，和SQL类似，它也可能存在注入风险。如果在应用中使用不可新的外部输入数据拼接GraphQL查询语句，则可能产生GraphQL注入而使应用执行预期之外的操作。
此外，应用以GraphQL接口对外提供API服务时，复杂的应用在GraphQL后端会有较多业务逻辑来处理和响应用户的查询请求，在GraphQL中称为Resolver函数。根据业务需要，Resolver可能会调用内部其他接口或访问数据库。
当GraphQL语句中的参数作为后端其他解释器的输入参数时(如SQL语句、OS命令、LDAP语句)，如果没有进行相应的安全处理，则可能在后端产生其他注入问题。例如，如下id参数包含单引号，可能导致后端SQL注入：
```
{
    bacon(id:1){
        id,
        type,
        price
    }
}
```
在部分GraphQL中间件中，其中Endpoint可接受表单形式的POST请求，或者可接受GET请求来执行Mutation，这种情况下还可能存在CSRF漏洞。
## OpenAPI规范
OpenAPI规范时Linux基金会的一个开源项目，其前身为Swagger规范。它是一种描述REST API格式定义的规范，比如API的：

+ 可用路径(如/user)以及每个路径允许的方法
+ 请求中的参数定义，以及响应内容的格式
+ 身份验证方法
OpenAPI规范可用YAML或者JSON格式来编写，不仅开发者容易读懂，而且也非常适合机器阅读，所以除了被当作API文档，它还适合用在程序中做自动化API格式校验。这种方式在安全产品中非常有效，有部分WAF产品支持导入API文档，用于校验请求是否符合API格式定义。这相当于使用白名单方式校验参数的合法性，如果应用中每个的API都有完整、精确的格式定义，这种白名单方式就可以防御绝大部分web攻击。
虽然OpenAPI规范在防御web攻击方面非常有效，但真正愿意花时间编写OpenAPI规范的开发者并不多。企业对此特性接收度并不高。
Swagger工具集是一套围绕OpenAPI规范的开源工具集，使用它可以快速设计、构建和使用REST API，包含了可视化的OpenAPI规范编辑器、自动化API文档生成器，甚至可以自动生成API客户端库(API的客户端SDK)
## 常见API漏洞
前文介绍了不同API框架的特点及其安全性，但很多时候API相关的漏洞是由于开发人员在应用层没有设置相应的安全措施所导致的。接下来，我们看一下在应用层常见的API安全漏洞
开源web应用安全项目(OWASP)从2019年开始发布安全的Top 10威胁。这份安全威胁列表是由来自社区的安全专家共同撰写的，它反映了当前面临的最关键的API安全威胁，以及API安全的发展趋势。
从技术上看，API安全漏洞很大一部分都属于常规web应用安全的范畴。但是在API场景中，有一部分安全漏洞更容易产生，或者具有更高的威胁。
下面介绍在API场景中更容易产生的安全漏洞
### 对象级授权失效
对象级授权失效是最常见的API安全漏洞，又称为"水平越权访问"，这种类型的漏洞在第14章已经讲过了，它是由于应用未校验用户访问的对象是否属于当前用户导致的。但是在API场景中，这种漏洞更容易出现，因为API不像常规web应用那样易暴露给测试人员，而且通常测试API比较麻烦，所以暴露在互联网上的API不一定经过了充分的安全性测试。
在一些移动App或IoT场景中，客户端的HTTP库不一定支持Cookie，所以一般不使用web应用框架中现成的Session+Cookie的会话方案，开发者需要自己实现客户端的身份和会话标识。通常是使用一个参数或HTTP头来标识，如果开发者考虑不周全(比如信任请求中的UID，以其作为身份标识)，也容易出现客户端篡改身份的漏洞，从而产生越权访问。
如果API使用的ID参数是随机字符串形式的(如GUID)，无法猜测出它的值，也就难以实现越权访问。但是，有些API除了接受GUID，同时也接受数字形式的ID，如userID=1234，这样就有可能通过遍历userID实现越权访问。
一部分编程语言有一种名为Type Juggling的特性，例如PHP语言中，(int)"123abc"的值为整数，又比如2*"3ab"的值为整数6。如果应用对这种场景处理不当，则攻击者可能绕过某些校验逻辑，从而产生越权访问，WordPress就产生过这种越权访问漏洞。
### 缺乏限速机制
缺乏限速机制是指API未对源IP地址或账号的请求频率，客户端可以在短时间内向服务器发起大量API调用请求。最典型的危害是数据爬取，例如，包含商品信息或用户身份信息的接口如果被大量调用，将产生数据泄露。
此外，在账号登录接口中，如果没有相应的限速策略，攻击者很容易对其发起密码暴力破解或者撞库攻击。
对于常规的web应用，我们有比较成熟的方案来应对机器爬虫或暴力破解攻击，最简单的方式就是使用图像验证码。但是，很多API场景中(比如IoT设备使用的接口)，难以实施类似的方案，所以在API中缺乏限速机制是一个普遍存在的安全问题。
当缺乏限速机制时，攻击者对API发起大量请求会影响服务器性能，甚至可以发起拒绝服务(Dos)攻击。
如果产生费用的API(如发送短信的接口)被攻击者滥用，将直接给企业带来资金损失。   
### 批量赋值
高度封装的应用框架容易出现批量赋值漏洞，如果API在接受用户请求时提交的参数时，未校验参数名是否在允许的白名单中，而直接将参数赋值给内部对象的属性，攻击者通过猜测或者阅读相关的API文档，可以构造特定的参数，让服务器程序覆盖对象的关键属性值。
SpringMVC和ASP.NET MVC中存在自动绑定的机制(Autobinding)，可以让请求中的参数自动绑定到对象属性上。假设User对象有如下三个属性：
```
public class User{
    private String username;
    private String password;
    private boolean isAdmin;
}
```
在正常的请求中，用户提交如下的参数被用于创建一个普通的账号：
```
POST /createUser
...
username=LaoWang&password=5201314
```
如果攻击者添加了参数isAdmin未true，将创建一个管理员账号：
```
POST /createUser
...
username=LaoWang&password=5201314&isAdmin=true
```
在Node.js和Ruby on Rails中也存在这样的机制，容易产生批量赋值漏洞，如：
```
var user = new User(req.body);
user.save();
```
此外，如果应用接收一个JSON格式的数据(这种做法在API中很常见)，并且将JSON数据反序列化未一个内部对象，攻击者构造带有特定键值对的JSON数据，也可能产生批量赋值漏洞。 
### API版本管理
在web应用中，用户只需要刷新页面，就能够访问最新版本的应用。但是在很多API场景中，调用者是客户端程序，我们很难做到让所有客户端都同时升级到最新版本，所以就存在多个API版本共存的问题。一种常见的做法是将API的版本写在URL路径中，如：
```
/api/v3/login
```
为了让旧版本的客户端还能调用API，通常这些API的v1和v2版本不会很快下线，时间久了之后，连开发者都忘记了它们的存在，其中存在的安全漏洞也不一定能及时得到修复。攻击者在寻找API安全漏洞时，会探测是否存在低版本的API，或者找到旧版本的客户端，分析其调用的API，在低版本的API中更有可能找到安全漏洞。
### 多场景中安全级别不一致
现在很多应用都需要为多种不同客户端提供访问接口，例如一个功能要为桌面浏览器、移动端webview、移动App分别提供API，但是开发者并不一定在这些API中都实现了相同的安全防护措施。这个问题很常见，有些应用在移动App及对应的API中做了很多安全方案，如App加固、通信数据加密、访问限速等等，但是对web端的API却没有设置对应的安全措施，或者让没有达到相同的防护水位。显然，攻击者会选择这些防护水位低的API进行突破。
### 过量的数据暴露
API向客户端返回数据时，开发者为了方便，直接返回数据对象的所有字段，然后在客户端(如App)过滤出业务需要的字段并显示出来。这种情况在客户端看不出异常，但是如果攻击者抓包或者自己去调用API，就可以获得API返回的其他数据，如果这个API是包含用户个人信息的接口，就将可能导致敏感数据泄露。
### 隐藏功能
开发API时，有时候开发者会过度设计其功能，或者使用的应用框架本身就自带了较多的功能，这些用不上的功能可能会带来意想不到的安全隐患；而且这些隐藏功能由于并没有被真正使用，所以在常规的测试中难以发现，经验丰富的攻击者会探测各种可能性，以找到更多突破口。
例如：一个返回JSON数据的API，在应用中它是给同源的web前端页面调用的，但是当添加一个callback参数时，它又返回JSONP格式的数据，如果没有相应的安全措施，它就可以实现跨域调用。攻击者发现这个隐藏功能，就可以跨域获取受害者在当前应用中的数据。 
有些API支持多种不同的数据格式。比如在应用中只使用了JSON格式，但是如果API同时也支持XML格式的数据，就有可能在服务端产生XML外部实体注入。因为正常情况下是没有这种请求，所以这种漏洞很难被发现。
在REST API中，如果过度启用了HTTP方法，也会带来安全隐患，比如DELETE和PUT方法可删除和上传任意数据。
### 未设置正确的Content-Type
API中返回的数据通常不是HTML内容，也不是给浏览器直接访问的，所以开发者容易忽视web前端相关的安全问题。大部分情况下，应用开发框架默认响应的Content-Type头为"text/html"，用浏览器直接访问这个接口时，浏览器会将响应内容当作HTML内容来渲染，这就有可能产生XSS漏洞。比如一个返回JSON数据的API未正确设置Content-Type，当返回如下内容时将产生XSS漏洞：
```
{"name":"<script>alert(123)</scritp>"}
```
## API安全实践
随着API的使用不断增长，企业面临的威胁不断扩大，越来越多的企业开始关注API安全建设，也有不少安全产品专门解决API安全问题。API安全涉及的范围很大，笔者根据自己的经验简要介绍一个下API安全建设的思路。
### API发现
首先，要知道有哪些API被发布到线上，以便进一步做安全测试或威胁分析。但是发现API并不是一件容易的事情，在业务复杂的场景中，应用程序使用的API数量庞大，而且每一次业务的发布或变更都可能带来API的变化。
我们可以通过本地测试抓包来发现应用程序使用的API，但这种做法对API的覆盖度有限。最常见的做法是在服务端分析访问日志，一个API只要被调用过，就能被自动发现。
但并不是所有API 都会在生产环境中被调用。一个很常见的安全隐患是，开发者在开发及测试程序时为了方便，设计一些具有特殊功能的API，但是在上线产品时忘记将这些API移除，而将风险带到了生产环境。这类API也称为影子API(Shadow API)，虽然它们不会被正常业务调用，但是一旦被攻击者发发现就可能成为突破口。所以如果条件允许，应该在开发和测试环境中就收集应用程序的访问日志，及早发现这些API并测试其安全性。
原始访问日志并不适合测试API安全。与web漏洞扫描器类似，我们需要对URL做一定的归一化(URL Normalization)处理。例如，下面两个获取用户信息的请求是在访问同一个API:
```
http://example.com/user1/profile
http://example.com/user2/profile
``` 
URL归一化非常重要，特别是在针对URL的攻击时(如数据爬取)，必须精确识别出不同的请求是在访问同一个API后，才能进一步分析。
自动化的URL归一化要考虑非常多的场景。在应用中，有些API的参数被放在Query中，也有的被放在Path中，后者需要做一定的统计分析后才能做归一化，这里就不详细介绍了。
### 生命周期管理
我们都知道要关注API在设计、开发、测试和上线过程中的安全，而API的下线安全则往往被忽视。随着应用功能变化和版本升级，总有旧的API不再被使用，由于旧版本客户端的存在，API的下线是个缓慢的过程，甚至可能被遗忘。如果这些API不能及时下线，后续很难得到安全支持，比如当相关组件爆出漏洞时不能及时打补丁，新设计的安全功能也不会被应用到已废弃的API上，因此这些API很有可能成为攻击者的突破口。
所以，有必要关注每个API的生命周期，及时发现已下线的API。在日志平台检测每一个API的调用量，自动发现调用量在下降的API，就可以及时发现需要下线的API。
### 数据安全
web应用中的大量数据安全事件都与API安全有关，例如当认证授权方案存在缺陷，或者缺乏限速措施时，攻击者都可以通过API获取大量数据。
解决API中的数据安全问题，首先要知道哪些API返回了敏感数据。在使用了统一接入网关的场景中，我们可以在网关侧识别HTTP响应中的敏感数据，这种串联方式还可以根据需要对数据脱敏。另一个常见的做法是使用流量镜像，旁路分析提取出HTTP响应内容，并检测其中的敏感数据。
还可以使用加密方案保护API数据，大量App和IoT设备使用的就是这种方式。客户端与服务端的通信数据经过了应用加密，再通过HTTP/HTTPS协议传输。因为数据加/解密要在客户端完成，而且加密算法可能被逆向分析出来，所以并不能做到100%保密，但是它在一定程度上提升了攻击门槛。
在应用内对数据加密，还需要权衡其他的利弊，比如数据加密后才能与服务端交互，即使应用有漏洞，攻击者也无法直接对应用发起攻击，但同时我们也无法使用网络安全产品在流量中做攻击检测，这给日志分析带来了很大障碍。
### 攻击防护
在API场景中，除了使用常规的web攻击防御方案，我们还可以通过OpenAPI规范定义API格式，在API网关或WAF产品中校验每个请求的格式，拦截不合法的请求。这实际上是对参数进行白名单校验，使得绝大多数web攻击都失效。
编写API的格式定义文件比较麻烦，现在也有部分WAF产品支持自动学习并生成每个API参数格式，但这需要积累一段时间的流量数据才行，只有访问过的API，才能为其生成格式。比如，一段时间内某API的id参数值都是数字格式，那么系统会认为该API的id参数的合法格式是长度在特定范围内的纯数字。这些训练数据必须来自正常的业务流量，其中不能混有攻击流量，不然会学习到错误格式。
在现实场景中，这个方法有一定效果，但直接用于拦截"不合法"的请求会有很大的风险，如果API有变更导致格式变化，就有可能产生误拦截。所以这个方法并没有在安全产品中大规模应用，系统生辰的规则即使用于拦截请求也需要先经过人工确认。
### 日志和审计
"缺乏日志记录和监控"排在API安全威胁的第10位，企业通常会对基础设施记录详细的安全日志，如操作系统的登录日志、网络攻击日志等，但经常会忽视API的日志记录及应用的访问日志监控。
但是，API的威胁检测极度依赖对访问日志的分析，不管是一次登录行为、无权拒绝访问，还是简单的访问商品详情页的行为，都可以被用于分析账号的异常表现。在应用中应当记录完整的访问日志，而且对这些日志要格式化存储，以便其他安全组件消费。需要注意的是，在日志中要避免记录敏感数据。
### 威胁检测
针对API的威胁非常多，与传统的web攻击相比，无法简单地从单个请求中发现针对API的攻击行为，而要分析一段时间内的访问行为才能做出判断。比如，检测针对登录接口的撞库、滥用短信发送接口、遍历参数爬取数据的行为时，都需要使用一段时间内的访问日志，根据(源IP地址，API)的二元组合进行聚合，判断访问量是否超过一定的阈值。如果业务比较复杂，或者要做一个通用的安全产品，我们不可能为每一个场景都设置阈值，这就需要安全系统足够智能，比如自动发现单位时间内访问量大幅超过历史平均水平的账号，或者访问行为大幅偏离正常账号行为的异常账号。
将日志导入大数据计算平台可以很方便地实现各种威胁检测模型。目前，很多计算平台，如Flink、MaxCompute、Hive等，都支持使用sql语言实现大数据计算，再加上Python的UDF，极大降低了开发复杂度。根据我们的经验，采用这种大数据平台做威胁检测，可以实现非常灵活的安全功能扩展。
### 使用API网关
如果企业有大量API供外部调用，而且这些API是不同团队开发的，就很难保证相同的安全水位。为了规范API并提供统一的安全防护，通常会使用API网关。
所有的API都通过一个网关向外提供服务，所以不管是攻击防护、身份认证、数据通信加密、威胁检测，都可以在API网关上实现，降低安全策略的实施成本，而且可以保证所有API的安全水位一致。
通常，在API网关上会叠加WAF功能，当出现新的安全漏洞时可以做到更快速的应急响应，添加新的防御规则实现全局防御。针对特定API的安全策略，如限速、限制源IP地址等，都可以只在网关上实现，而无需在应用中对所有的API都实现相应的功能。
### 微服务安全
微服务架构是近几年非常热门的概念，其核心思想是将应用拆分成高度解耦的一系列服务，服务之间通过标准的接口进行数据通信。
原先的单位变成微服务架构后，面临新的安全挑战。由于各种微服务都部署在不同的Pod(Kubernetes中可独立运行的服务单元)中，它们之间的调用需要通过RPC来实现，这就涉及到微服务之间的认证和授权。
在云原生微服务架构中通常会使用sidecar模式，将一个7层代理容器以sidecar模式运行在Pod中，来完成微服务之间的所有网络通信，与API安全有关的功能也在sidecar容器中完成，比如身份认证、授权、日志采集等。