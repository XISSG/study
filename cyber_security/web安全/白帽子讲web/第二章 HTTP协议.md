# 第二章
# HTTP协议
### http请求
常用http方法：

|   方法   |              用途               |
| ------- | ------------------------------ |
| OPTIONS | 用于客户端向服务端查询支持的方法    |
| GET     | 像服务端获取URI指定的资源          |
| HEAD    | 与GET类似，但是服务端不返回实际内容 |
| POST    | 向服务端提交数据                  |
| PUT     | 向指定的URI存储文件               |
| DELETE  | 删除URI指定的服务器上的文件        |
| TRACE   | 让服务器回显请求中的内容           |
| CONNECT | 用于在http协议中建立代理隧道       |
+ GET和HEAD方法对服务端是“只读”的操作，因此被称为安全的方法，其他对服务端有增、删、改数据的操作则是对服务端不安全的方法。GET方法刷新页面不会要求用户确认。POST方法刷新页面会要求用户确认，避免在服务端有多余的操作，重复下单交易之类的
+ PUT和DELETE 方法用于文件上传和删除，一般不会用到，都会被禁用。某些API可能会用来操作服务器上除文件以外的其他资源
+ 敏感数据尽量通过POST方法提交。CDN，防火墙，web服务器等日志都会记录请求中URL的内容，跳转到其他站点时，还会通过referer头携带给其他网站，造成敏感数据泄漏
+ 服务端请求数据时，尽量指明从GET参数还是从POST参数中获取，否则容易被绕过只针对POST请求的安全策略。尽量不要使用$_REQUEST中获取请求参数
+ TRACE常用于诊断调试，服务端直接返回请求的内容，在XSS攻击中可以以此来绕过Cookie的HttpOnly策略，需禁用TRACE方法
+ HEAD和GET方法消耗的计算机资源是一样的，HEAD对带宽要求更小，因此常用作DDos攻击，可以在不超过带宽阈值情况下，耗尽计算机资源
+ CONNECT方法用于在客户端和目标地址之间建立一个TCP隧道，web服务器充当代理服务器，可以以此建立从外网穿透到内网的传输隧道
+ HTTP1.1相较于HTTP1.0的新特性：支持持久化连接（允许复用一个TCP连接完成多个 http请求）、支持管线化（在一个TCP连接的客户端中无需等待前一个请求的响应，就可发送下一个请求）、新增HOST头用于虚拟主机的场景（一个IP地址上运行多个网站时，用于指定要访问的目标网站）
+ User-Agent用来指示当前访问者的客户端类型，可能会包含恶意内容，插入XSS Payload，以便对后端日志分析平台实现XSS盲打
+ Referer用于指定当前请求是从哪个URL页面发起的，在旧版的flash中该值可以伪造，现在浏览器不能通过JavaScript伪造该头。Referer做来源校验是可靠的，只能信任其域名，不能信任URL级别的内容
+ 不同浏览器对相同页面的请求头的个数、顺序和值都有差异
### http响应
响应的版本号可以不与请求的版本号相同，但是大版本号不能高于请求的版本号
状态码，用于指示服务器对该请求的操作结果
+ 100～199 服务器收到请求，但未完成操作
+ 200～299 请求中的操作已完成
+ 300～399 告知客户端执行额外的操作，通常用于跳转
+ 400～499 客户端请求出错
+ 500～599 服务端出错
**状态码能用来做安全分析：**
一个访问者在短时间内产生了大量的404响应，可能是攻击者在做大量的网站扫描探测
某个页面有大量的500响应，意味着程序存在BUG，甚至代码中存在sql注入漏洞

http的响应头是通过"\r\n"进行分隔的，如果请求的数据会出现在响应头中，这些数据未经严格过滤时，可能产生http消息头注入（CRLF注入）。在受害者的响应中注入了Location头，可将受害者重定向到指定网站；注入Set-Cookie头，可以让受害者使用攻击者指定的Cookie值，实施固定会话攻击等；在跨域资源共享（CORS）和内容安全策略（CSP）注入特定响应头，可以改变浏览器接收到的安全策略，以便攻击者实施其他攻击行为
### http/2
使用了请求头压缩，常见的http头会用键值对表示
用于提升网络性能
### http/3
使用UDP协议和上层的QUIC协议，语义和之前版本相同
免去TCP的三次握手协议，进一步提升网络性能
QUIC协议在用户态实现了类似TCP的面向连接、传输可靠等特性
### websocket
为浏览器和服务器提供全双工通信模式（HTTP是单工通信），构建在http协议之上，支持http代理，使用长连接。
使用ws或者wss的同一资源定位符（URI），wss是使用了TLS的websocket
```
ws://echo.websocket.org
wss://echo.websocket.org
```
websocket与http和https使用相同的TCP端口，可以绕过绝大多数的防火墙限制。
在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。
优点：

+ 较小的控制开销：建立连接后，用于协议控制的数据包头较小
+ 更强的实时性：全双工通信的优势，服务器可随时发送数据给客户端，延迟更低
+ 保持连接状态：websocket通信前需进行建立连接，这使其成为了有状态的协议
+ 更好的二进制支持：定义了扩展，用户可以扩展协议，实现部分自定义的子协议

    如何进行握手的
WebSocket的握手过程如下：

+ 客户端发送一个HTTP请求给服务器，请求的头部包含Upgrade字段，值为"websocket"，以表明希望升级到WebSocket协议。

+ 服务器收到请求后，会检查Upgrade字段，如果存在且值为"websocket"，则表示客户端希望升级到WebSocket协议。服务器会返回一个HTTP响应，状态码为101 Switching Protocols，表示协议切换成功。

在HTTP响应的头部中，服务器会包含以下字段：

+ Upgrade: websocket，表示服务器同意升级到WebSocket协议。
+ Connection: Upgrade，表示连接类型为升级。
+ Sec-WebSocket-Accept，该字段是服务器生成的一个校验值，用于验证客户端的握手请求的合法性。
+ 客户端收到服务器的响应后，会检查状态码是否为101 Switching Protocols，并且检查响应头中的Upgrade和Connection字段，确保服务器同意升级到WebSocket协议。

客户端还会检查Sec-WebSocket-Accept字段，通过对Sec-WebSocket-Key和一个固定的GUID进行加密生成一个校验值，然后与服务器返回的Sec-WebSocket-Accept进行比较，以验证服务器的握手响应的合法性。

握手成功后，连接升级为WebSocket协议，双方可以进行实时的双向通信。

需要注意的是，WebSocket的握手过程是基于HTTP协议的，所以在握手阶段需要进行HTTP请求和响应。握手成功后，连接会升级为WebSocket协议，后续的通信数据将按照WebSocket协议进行传输。
## web服务器
通过http/https协议向访问者提供服务，可以是一台服务器或一个服务器集群
web服务器提供的内容按照存在形式分为两类：静态资源和动态资源

+ 静态资源：指服务器上已存在的文件，客户端访问时，web服务器直接将它返回给客户端，这类资源通常是可以缓存
+ 动态资源：值服务器需要经过计算才能生成的内容，比如查询结果，通常不缓存

访问web应用时并不都是直接访问web服务器的，中间可能经过http代理，其中可能是客户端指定的正向代理，也有网站使用的CDN、WAF、负载均衡等反向代理。
## Web页面
### 文本对象模型（DOM）
文档文本对象模型是浏览器对网页上各种元素的一种结构化表示形式
![](vx_images/470252800836625.png =504x)
### Javascript
javascript能够读取和操作DOM中的节点，还能与服务端交互，也能作为一门独立的通用型语言，如在服务端的 Node.js。
javascript是动态类型的语言，不利于编写大型复杂应用，微软推出TypeScript作为javascript的超集，支持静态数据类型，拥有更好的面向对象开发特性。可以将TypeScript编译成javascript代码在浏览器中运行
因为在客户端执行，容易恶意篡改，因此会进行代码混淆，增加攻击者利用成本
